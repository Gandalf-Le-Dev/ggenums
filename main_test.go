package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/Gandalf-Le-Dev/ggenums/generator"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerate(t *testing.T) {
	tests := []struct {
		name        string
		enumDef     string
		typeNames   []string
		expected    []string
		expectError bool
	}{
		{
			name: "basic enum generation",
			enumDef: `package test

//go:generate ggenums -type=Status
type Status int
const (
	StatusPending Status = iota
	StatusActive
	StatusCompleted
	StatusInProgress
)
`,
			typeNames: []string{"Status"},
			expected: []string{
				"package test",
				"var allStatuss = []Status{",
				"func ParseStatus(s string) (Status, error)",
				"func (e Status) String() string",
				"func (e Status) IsValid() bool",
			},
			expectError: false,
		},
		{
			name: "enum with single value",
			enumDef: `package test

//go:generate ggenums -type=State
type State int
const (
	StateActive State = iota
)
`,
			typeNames: []string{"State"},
			expected: []string{
				"package test",
				"var allStates = []State{",
				"func ParseState(s string) (State, error)",
				"func (e State) String() string",
				"func (e State) IsValid() bool",
			},
			expectError: false,
		},
		{
			name: "enum with complex values",
			enumDef: `package test

//go:generate ggenums -type=Priority
type Priority int
const (
	PriorityVeryLow Priority = iota
	PriorityLow
	PriorityMedium
	PriorityHigh
	PriorityVeryHigh
)
`,
			typeNames: []string{"Priority"},
			expected: []string{
				"package test",
				"var allPrioritys = []Priority{",
				"func ParsePriority(s string) (Priority, error)",
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a temporary directory
			tmpDir := t.TempDir()

			// Create the test enum definition file
			fileName := "test_enum.go"
			err := os.WriteFile(filepath.Join(tmpDir, fileName), []byte(tt.enumDef), 0644)
			require.NoError(t, err, "Failed to create test file")

			// Run the generator
			g := generator.NewGenerator(tmpDir, tt.typeNames)
			err = g.Parse()
			require.NoError(t, err, "Failed to parse")

			err = generate(g)
			if tt.expectError {
				require.Error(t, err)
				return
			}
			require.NoError(t, err, "Failed to generate")

			// Check if the generated files exist (one per type)
			for _, typeName := range tt.typeNames {
				generatedFile := filepath.Join(tmpDir, strings.ToLower(typeName)+"_enum_generated.go")
				content, err := os.ReadFile(generatedFile)
				require.NoError(t, err, "Failed to read generated file")

				// Check that all expected strings are present
				generatedContent := string(content)
				for _, expected := range tt.expected {
					assert.Contains(t, generatedContent, expected,
						"Generated content missing expected string: %s", expected)
				}

				// Additional validation: ensure the generated file is valid Go
				assert.Contains(t, generatedContent, "package test",
					"Generated file should contain package declaration")
				assert.Contains(t, generatedContent, "// Code generated by ggenums",
					"Generated file should contain generation comment")
			}
		})
	}
}

func TestGenerate_MultipleEnums(t *testing.T) {
	// Create a temporary directory
	tmpDir := t.TempDir()

	// Create a test file with multiple enum definitions
	enumDef := `package test

//go:generate ggenums -type=Status,Priority
type Status int
const (
	StatusPending Status = iota
	StatusActive
	StatusCompleted
)

type Priority int
const (
	PriorityLow Priority = iota
	PriorityMedium
	PriorityHigh
)
`
	err := os.WriteFile(filepath.Join(tmpDir, "enums.go"), []byte(enumDef), 0644)
	require.NoError(t, err)

	// Run the generator
	g := generator.NewGenerator(tmpDir, []string{"Status", "Priority"})
	err = g.Parse()
	require.NoError(t, err)

	err = generate(g)
	require.NoError(t, err)

	// Check if the generated files exist (one per enum)
	statusFile := filepath.Join(tmpDir, "status_enum_generated.go")
	priorityFile := filepath.Join(tmpDir, "priority_enum_generated.go")

	statusContent, err := os.ReadFile(statusFile)
	require.NoError(t, err)
	priorityContent, err := os.ReadFile(priorityFile)
	require.NoError(t, err)

	// Check Status enum
	statusChecks := []string{
		"var allStatuss = []Status{",
		"func ParseStatus(s string) (Status, error)",
	}

	for _, check := range statusChecks {
		assert.Contains(t, string(statusContent), check)
	}

	// Check Priority enum
	priorityChecks := []string{
		"var allPrioritys = []Priority{",
		"func ParsePriority(s string) (Priority, error)",
	}

	for _, check := range priorityChecks {
		assert.Contains(t, string(priorityContent), check)
	}
}

func TestGenerate_EmptyDirectory(t *testing.T) {
	// Create a temporary directory with no Go files
	tmpDir := t.TempDir()

	// Run the generator
	g := generator.NewGenerator(tmpDir, []string{"Status"})
	err := g.Parse()
	require.NoError(t, err)

	err = generate(g)
	require.NoError(t, err)

	// Verify no files were generated
	files, err := os.ReadDir(tmpDir)
	require.NoError(t, err)
	assert.Empty(t, files, "No files should be generated for empty directory")
}

func TestGenerate_NoMatchingTypes(t *testing.T) {
	// Create a temporary directory
	tmpDir := t.TempDir()

	// Create a Go file without matching enum types
	goFile := `package test

type SomeStruct struct {
	Field string
}

func SomeFunction() {
	// Just a regular comment
}
`
	err := os.WriteFile(filepath.Join(tmpDir, "regular.go"), []byte(goFile), 0644)
	require.NoError(t, err)

	// Run the generator looking for a type that doesn't exist
	g := generator.NewGenerator(tmpDir, []string{"Status"})
	err = g.Parse()
	require.NoError(t, err)

	err = generate(g)
	require.NoError(t, err)

	// Verify no enum files were generated
	files, err := os.ReadDir(tmpDir)
	require.NoError(t, err)

	// Should only contain the original file
	assert.Len(t, files, 1)
	assert.Equal(t, "regular.go", files[0].Name())
}
