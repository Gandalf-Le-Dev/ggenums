package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/Gandalf-Le-Dev/ggenums/generator"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerate(t *testing.T) {
	tests := []struct {
		name        string
		enumDef     string
		enumName    string
		expected    []string
		expectError bool
	}{
		{
			name: "basic enum generation",
			enumDef: `package test

//go:generate ggenums
//enum:name=Status values=pending,active,completed,in_progress
`,
			enumName: "Status",
			expected: []string{
				"package test",
				"type Status int",
				"StatusPending Status = iota",
				"StatusActive",
				"StatusCompleted",
				"StatusInProgress",
				"func ParseStatus(s string) (Status, error)",
				"func (e Status) String() string",
				"func (e Status) IsValid() bool",
			},
			expectError: false,
		},
		{
			name: "enum with single value",
			enumDef: `package test

//enum:name=State values=active
`,
			enumName: "State",
			expected: []string{
				"package test",
				"type State int",
				"StateActive State = iota",
				"func ParseState(s string) (State, error)",
				"func (e State) String() string",
				"func (e State) IsValid() bool",
			},
			expectError: false,
		},
		{
			name: "enum with complex snake_case values",
			enumDef: `package test

//enum:name=Priority values=very_low,low,medium,high,very_high
`,
			enumName: "Priority",
			expected: []string{
				"package test",
				"type Priority int",
				"PriorityVeryLow Priority = iota",
				"PriorityLow",
				"PriorityMedium",
				"PriorityHigh",
				"PriorityVeryHigh",
				"func ParsePriority(s string) (Priority, error)",
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a temporary directory
			tmpDir := t.TempDir()

			// Create the test enum definition file
			fileName := strings.ToLower(tt.enumName) + ".go"
			err := os.WriteFile(filepath.Join(tmpDir, fileName), []byte(tt.enumDef), 0644)
			require.NoError(t, err, "Failed to create test file")

			// Run the generator
			g := generator.NewGenerator(tmpDir)
			err = g.Parse()
			require.NoError(t, err, "Failed to parse")

			err = generate(g)
			if tt.expectError {
				require.Error(t, err)
				return
			}
			require.NoError(t, err, "Failed to generate")

			// Check if the generated file exists (named after the enum name, not the source file)
			generatedFile := filepath.Join(tmpDir, strings.ToLower(tt.enumName)+"_enum_generated.go")
			content, err := os.ReadFile(generatedFile)
			require.NoError(t, err, "Failed to read generated file")

			// Check that all expected strings are present
			generatedContent := string(content)
			for _, expected := range tt.expected {
				assert.Contains(t, generatedContent, expected, 
					"Generated content missing expected string: %s", expected)
			}

			// Additional validation: ensure the generated file is valid Go
			assert.Contains(t, generatedContent, "package test",
				"Generated file should contain package declaration")
			assert.Contains(t, generatedContent, "// Code generated by ggenums",
				"Generated file should contain generation comment")
		})
	}
}

func TestGenerate_MultipleEnums(t *testing.T) {
	// Create a temporary directory
	tmpDir := t.TempDir()

	// Create a test file with multiple enum definitions
	enumDef := `package test

//enum:name=Status values=pending,active,completed
//enum:name=Priority values=low,medium,high
`
	err := os.WriteFile(filepath.Join(tmpDir, "enums.go"), []byte(enumDef), 0644)
	require.NoError(t, err)

	// Run the generator
	g := generator.NewGenerator(tmpDir)
	err = g.Parse()
	require.NoError(t, err)

	err = generate(g)
	require.NoError(t, err)

	// Check if the generated files exist (one per enum)
	statusFile := filepath.Join(tmpDir, "status_enum_generated.go")
	priorityFile := filepath.Join(tmpDir, "priority_enum_generated.go")
	
	statusContent, err := os.ReadFile(statusFile)
	require.NoError(t, err)
	priorityContent, err := os.ReadFile(priorityFile)
	require.NoError(t, err)

	// Check Status enum
	statusChecks := []string{
		"type Status int",
		"StatusPending Status = iota",
		"StatusActive",
		"StatusCompleted",
		"func ParseStatus(s string) (Status, error)",
	}
	
	for _, check := range statusChecks {
		assert.Contains(t, string(statusContent), check)
	}

	// Check Priority enum
	priorityChecks := []string{
		"type Priority int",
		"PriorityLow Priority = iota",
		"PriorityMedium",
		"PriorityHigh",
		"func ParsePriority(s string) (Priority, error)",
	}
	
	for _, check := range priorityChecks {
		assert.Contains(t, string(priorityContent), check)
	}
}

func TestGenerate_EmptyDirectory(t *testing.T) {
	// Create a temporary directory with no Go files
	tmpDir := t.TempDir()

	// Run the generator
	g := generator.NewGenerator(tmpDir)
	err := g.Parse()
	require.NoError(t, err)

	err = generate(g)
	require.NoError(t, err)

	// Verify no files were generated
	files, err := os.ReadDir(tmpDir)
	require.NoError(t, err)
	assert.Empty(t, files, "No files should be generated for empty directory")
}

func TestGenerate_NoEnumComments(t *testing.T) {
	// Create a temporary directory
	tmpDir := t.TempDir()

	// Create a Go file without enum comments
	goFile := `package test

type SomeStruct struct {
	Field string
}

func SomeFunction() {
	// Just a regular comment
}
`
	err := os.WriteFile(filepath.Join(tmpDir, "regular.go"), []byte(goFile), 0644)
	require.NoError(t, err)

	// Run the generator
	g := generator.NewGenerator(tmpDir)
	err = g.Parse()
	require.NoError(t, err)

	err = generate(g)
	require.NoError(t, err)

	// Verify no enum files were generated
	files, err := os.ReadDir(tmpDir)
	require.NoError(t, err)
	
	// Should only contain the original file
	assert.Len(t, files, 1)
	assert.Equal(t, "regular.go", files[0].Name())
}
